* Basic
  functional language feature: function is first class, immutable
  because foldRight is not tail rec, will cause stackoverflow, foldRight can use foldLeft to presentation, two way implement:
   - foldRight f acc xs = foldLeft (x y -> f y x) acc (reverse xs)
   - foldRight f acc xs = (foldLeft (x y -> z -> x(f y z)) (x -> x) xs) acc
  trait Map[Key,Value] extends (Key => Value)
  trait Seq[Elem] extends (Int => Elem)
  case { xx => yy } is a PartialFunction, compiler auto generate isDefiendAt function for top level case
  companion object apply call by className(), class apply call by instance()
  function is object, apply is function body
  try .. finally, if finally return, use finally result(java will keep try block return)
  : _* change seq to variadic argument
  closure means if function is out of function variable, will bind to fact variable, not just a value, be captured value will be replace from stack to heap by compiler
  final can disallow method or class be extend
  trait can mix multiple, class can't
  trait no argument constructor, method can override, super is dynamic binding
  def funcName {}, define a function
* frp(function reactive programming)
  signal is use to replace event, signal can update, all depend on this signal's signal will be updated
  simple implement:  keep a stack, stack top is it's next level's observer, bottom is above's notifier, when call update, will cancel all notify this signal's notifier, because this signal watch value changed, then push this signal to stack top, evaluate new value, then cancel all this signal notifited(it will re-added on their update)
  T => Try[S] express a maybe throw exception expression
  Feature[T] express a need time to calculate expression
* Future
  Future {callBack} {ExecuteContext} create a Future, callBack is future execute body, executeContext is thread pool info
  Future {blocking {call}} {ExecutingContext} use current thread to execute
  ExecuteContext has a implicit parameter
  Future has two state, uncomplete and complete, complete has success and failure status
  Future's value can assign once
  onComplete(Try[T] => Unit) is callback when future complete
  onSuccess(T => Unit) is only called when success
  onFailure(Throwable => Unit) is only called when failure
  recover(Throwable => Unit) execute when failure, return a backup value
  recoverWith(Throwable => Future[T]) execute when failure, cover failure use new Future
  fallbackTo(Throwable => Future[T]), most same as recoverWith, but if failure again, recoverWith return second future error, this method return first future failure
  andThen(T => Future[T]), execute when previous future finish, is in order execute
  Awaitable is used to test future
  Await.result(Future, delay time) after duration time return T
  Promise is a carrier for Future, can use success/failure/complete to assign, only assign only once
* Library
** quickCheck
   let class extend Peropeties, forAll { a: Type => xx }, a is generated, last expression is bool
** actor 
   only interact with message
   !(send) send message to a actor
   self means self
   actorOf create a child actor
   stop, stop a actor
   context.parent get creator
   context.system.scheduler.scheduleOnce(duration) {block} execute a callback after set time duration on other thread
   override supervisorStrategy change failure strategy
   extend PersistenActor and implement persist to persist event
* Api
  scala.language.postFixOps define well Duration format, e.g. 1826 minutes
    scala.async.Async._ define async { await {}} syntax
* Repl
  scala, start repl
  | is mutiple line input mode
  :cp import class file or -cp when start interpreter
  scala <file> execute file

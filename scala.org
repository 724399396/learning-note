* Basic
  functional language feature: function is first class, immutable
  closure means if function has free variable, will bind to outside variable, this variable is replace from stack to heap by compiler
  companion object apply call by className(), class apply call by instance()
  function is object, apply is function body
  try catch finally is also a expression, value is try or catch value, finally execute but not as expression value, but if finally call return, use finally result(java will keep try block return)
  _* change seq to variadic argument
  closure means if function is out of function variable, will bind to fact variable, not just a value, be captured value will be replace from stack to heap by compiler
  final can prevent method/field be override or class be extend
  trait can mix multiple, class can't
  trait no argument constructor, method can override, super is dynamic binding, super call is from right to left, initialize is from left to right
  rich interface is means has kinds of method interface, client use easy but implement is hard
  thin interface is means little method interface
  trait <A> extends <B> means mixed trait A must mixed trait B
  scala everything is amost object
  def funcName {}, define a function
  for (i <- list) iterate element, the variable i is immutable
  <low> to <up> by <step> generate Range, can omit by <step> then step is 1
  (<e1>,<e2>) construct tuple, _1 or _2 access element
  class <Name>(<args>) {body} define a class, all body is execute when create instance, def this() is help constructor(execute after initial sentence), args can has modifier like private/override
  object <Name> defined a singleton object
  define a object use name same as class, then this object is called companion object, they can access each other
  plcae class to companion object to hide implement detial for client
  preserved keyword `override` used to override field/method
  class extend need provide parent constructor argument
  var means variable, mutable
  val means value, immutable
  base collection: Seq, Map, Set
  Any is root object type, Nothing is bottom object type, AnyVal is primary type root type, AnyRef is reference type root type, Unit is AnyVal subclass, all AnyVal is abstract, can't new only exist literal
  method ends with `:` is right association
  "reg".r is regular expression
  xx match { case <match> [if <condition>]  => } is pattern match format
  <instance>(<arg>) = <newValue> equal to instance.update(arg, newValue)
  :: concat elem and list, ::: concat list and list
  Console.err is standard err stream, Console.stdout is standard stream
  iterator can only iterate once
  every type can convert to Unit, if method not use concat `=` define and body, result will be Unit
  scala can put class file in any .scala file
  integral is basica number type, numeric is float type
  scala and java.lang package is auto imported
  0x<num> write literal hex number, scala always show decimal number
  \u<num> unicode encode
  """<string>""" define raw string, don't need any escape, | trim lead space
  'a is symbol a
  -2.0 is equal to (2.0).unary_-, only +, -, !, ~ can use as unary prefix operator
  == will call equals method, compiler will avoid NPE, eq compare object address, ne is symmetric
  scala method first character decide precedence, = ended is lowest precedence, last character decide association order
  require can used to check argument
  assert(condition) assert(condition, explanation) used to check state
  ensure(condition) used to check result
  implicit is use to convert type implicitly
  scala assignment return type is Unit
  for <clause> yield <body>
  throw <exception>, exception can pattern match in catch
  scala function can nested
  (<v>: <Type) => <expression> define a function
  _ is variable place holder 
  def <name>(<v>: <type>*), defined method accept variable argument
  when tail recursion method throw exception, stack only one level(tail recursion optimize)
  when function is currying, {} can replace ()
  :=> xx means pass by name(lazy evaluate)
  abstract class, leave method no implement is abstract method
  no parameter function is same as field, can override each other, if has side effect, add ()
  scala only two namespace: value(method, field, package, object), type(class, trait)
  ScalaObject contain $tag method, target is improve pattern match performance
  package can define anywhere, scala package and field is same namespace, so can override each other
  import can import class/object/field/method/argument, can use anywhere
  import <x>.{A,B} import A and B
  import <x>._ import all element from package x
  import <x>.{A => <name>} import A use <name>
  import <x>.{A => _, _} import all but hide A
  scala permission modifer is scoped, e.g. private filed can be access from inner object
  private[X], X can be private,protected,this
  because foldRight is not tail rec, will cause stackoverflow, foldRight can use foldLeft to presentation, two way implement:
   - foldRight f acc xs = foldLeft (x y -> f y x) acc (reverse xs)
   - foldRight f acc xs = (foldLeft (x y -> z -> x(f y z)) (x -> x) xs) acc
  trait Map[Key,Value] extends (Key => Value)
  trait Seq[Elem] extends (Int => Elem)
  case { xx => yy } is a PartialFunction, compiler auto generate isDefiendAt function for top level case
* frp(function reactive programming)
  signal is use to replace event, signal can update, all depend on this signal's signal will be updated
  simple implement:  keep a stack, stack top is it's next level's observer, bottom is above's notifier, when call update, will cancel all notify this signal's notifier, because this signal watch value changed, then push this signal to stack top, evaluate new value, then cancel all this signal notifited(it will re-added on their update)
  T => Try[S] express a maybe throw exception expression
  Feature[T] express a need time to calculate expression
* Future
  Future {callBack} {ExecuteContext} create a Future, callBack is future execute body, executeContext is thread pool info
  Future {blocking {call}} {ExecutingContext} use current thread to execute
  ExecuteContext has a implicit parameter
  Future has two state, uncomplete and complete, complete has success and failure status
  Future's value can assign once
  onComplete(Try[T] => Unit) is callback when future complete
  onSuccess(T => Unit) is only called when success
  onFailure(Throwable => Unit) is only called when failure
  recover(Throwable => Unit) execute when failure, return a backup value
  recoverWith(Throwable => Future[T]) execute when failure, cover failure use new Future
  fallbackTo(Throwable => Future[T]), most same as recoverWith, but if failure again, recoverWith return second future error, this method return first future failure
  andThen(T => Future[T]), execute when previous future finish, is in order execute
  Awaitable is used to test future
  Await.result(Future, delay time) after duration time return T
  Promise is a carrier for Future, can use success/failure/complete to assign, only assign only once
* Library
** quickCheck
   let class extend Peropeties, forAll { a: Type => xx }, a is generated, last expression is bool
** actor 
   only interact with message
   !(send) send message to a actor
   self means self
   actorOf create a child actor
   stop, stop a actor
   context.parent get creator
   context.system.scheduler.scheduleOnce(duration) {block} execute a callback after set time duration on other thread
   override supervisorStrategy change failure strategy
   extend PersistenActor and implement persist to persist event
* Api
  scala.language.postFixOps define well Duration format, e.g. 1826 minutes
    scala.async.Async._ define async { await {}} syntax
* Repl Scala(command)
  scala, start repl
  | is mutiple line input mode
  :cp import class file 
**  scala unix shell script
 #+BEGIN_CENTER bash
 #!/bin/sh
 exec scala "$0" "$@"
 #+END_CENTER
** scala
  scala <file>, execute scala file
  -cp, set class path
  -g:notailcalls, close tail rec optimization

* jvm options
JAVA_OPTS="" scala, config jvm argument

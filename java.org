* Mybatis
namespace is used to distinct mapper file, good practice is keep same with java class full path
SqlSession is not thread safe
typeHandler is used to convert between sql data and java object
ObjectFactory used to from sql data to build java object
** basic query
    - (ExpectType) session.selectOne("<mapper file full name>", id)
    - session.getMapper(class).selectXX(id)
** page limit
   use RowBounds class
** DSL 
*** typeAliases
    set type aliases
*** id
    set this column is id, useGeneratedKeys set this id is from database generated
*** resultType
    this column return type
*** resultMap
    custom type for this column return
** Dynamic sql
   #{x} in dynamic sql is from two source, one is get("x") method, another is getX(), get("x") is high priority.
   <if test="<condition>"> <sentence></if>
   <where test="<condition"></where> can handle where and and nicely
   <set> can handle set and , nicely
   <foreach>
** setting
   <setting name="logIm

   

    

* Elastic Search
  use bin/elasticsearch start es, default port is 9200
  bin/plugin -i install plugin
** http api
  Get to query data
  Put to insert data
  location is <index>/<type>/<id>
  <location>/_search?q=<condition> or POST <location>/_search pass query condition to query data
  Index(table) -> Document(row) -> Field(cell)
  _shutdown shutdown es
  _plugin/<plugin name> access plugin
  filter like where, aggregation like group
  _cluster/health get every node info
  shard is basic data unit, one index include multiple shard, only exist one primary shard, exist zero to many replica shard
  primary shard is decide when start up, can't changed except restart, replica shar
* Concurrency
  mutable is root cause when concurrency
  count++ is race condition, also is data race
  race condition general case is check-then-act or read-modify-write
  static method use lock is class
  if need protect a class multiple field, should use same lock to protect together
  concurrency should solve two sub-problem, one is atomic, another is visibility
  64 bit operate is not atomic, use volatile can ensure atomic
  lock ensure atomic and visibility
  volatile let variable can't be re-order, can't be cache, visibility to all thread
  volatile only suit those scenarios
    1) write a variable not depend on current value
    2) only one thread to write this variable, this variable is not a part of object same
  walk on a object can reach field means is public, pass a object to a method also means public this object, public a internal object means public it outside object
  don't public this on constructor, general case is create thread on constructor
  Thread Confinement, keep a object only exist on one thread, it ensure thread safe.
  Thread local object, when first thread first call get method, initialValue will be called
  Immutable object always thread safe.
  safe publish object way:
    1) static field initial a object
    2) use volatile or AtomicReference
    3) final field save initialed object
    4) use lock to publish object
    5) thread safe collection to publish
  use private object to as lock
  an object has multiple field, use separate thread safe collection to ensure every field can make object safe if every field is independent
  if document not declare it is thread safe, means it is not thread safe
  when use iterator on thread safe collection, will record a count, if count change, any then getNext and hasNext will throw ConcurrentMOdificationException
  collection toString, xxAll, hasCode maybe use iterator
  Queue is add after 5.0, purpose is improve performance when random access, BlockingQueue is good choice to implement producer/consumer strategy
* Spring
spring core is IoC and AOP
IoC is let container maintain object lifecycle
** IOC
   two initial way:
     1) BeanFactory only IoC, initialize lazy
     2) ApplicationContext, extend from BeanFactory, support AOP, egar initialize
   bean initialize way:
     1) default constructor
     2) factory-method set initialize method of this class static method
     3) set factory-bean and factory-method
     4) <constructor-arg>, can set by type, by index or by name
   cycle depedency will throw BeanCurrentlyInCreationException
   constructor:
      <null/> use to set null
      depende-on set the class will initialize after depende-on class
   @autowire inject by name or by type, if same type has multiple instance, throw exception
   lifecycle:
      - singleton
      - prototype, multiple instance
      - request, one request one instance
      - session
      - application
** AOP
   <aop: scoped-proxy proxy-target-class="false"> set base on interface proxy
   @Around to implement aop
** Spring mvc
   two container:
     - tomcat ContextLoaderListener, this class will initialize WebAppicationContext,
       keep DAO and service, then register a DispatcherServlet, this class will read
       <servlet-name>-servlet.xml then construct the second container
     - the second container's parent is above container, so can read service and dao
       instance, incluse HanlderMapping(for http), HandlerAdapter, ModelAndView is
       use to response, ViewResolver is to find view.
   three implement method:
     - implement HttpRequestHandler then override handleRequest, then register on
       second on container
     - extend AbstractController, implement RequestInternal method, return ModelAndView
     - use @Controller on class, @RequestMapping on Method then return ModelAndView, @RequestParam bind
       parameter from request, @RequestHeader get Header value, @CookieValue get coockie, @RequestBody
       @PathVariable get url path, @ResponseBody custom response format
   extend HandlerExceptionResolver then implement resolveExcpeiton then register in container to handle global exception
   @ExceptionHandler set non global exception handler
   HandlerInterceptor intercept request before handle, after handle then after view resolve
   <welcome-file-list> set 404 error page
   
       
   

* Mybatis

  general usage:

  - Blog blog = (Blog) session.SelectOne(<mapper name>, args)

  - BlogMapper mapper = session.getMapper(<mapper class>)

    Blog blog = mapper.selectBlog(arg)



  namespace is used to distinct mapper file, good practice is keep same with java class full path

  SqlSession is not thread safe

  SqlSessionFactory is best only create single instance

** basic query

   - (ExpectType) session.selectOne("<mapper file full name>", id)

   - session.getMapper(class).selectXX(id)

** page limit

   use RowBounds class

** mapper file 

   - id

     set this column is id, useGeneratedKeys set this id is from database generated

   - resultType

     this column return type

   - resultMap

     custom type for this column return

   - constructor

     set return type constructor, maybe argument <idArg> <arg>

   - association

     complicate object

   - cache

     define cache on/off, choose cache implementation

** Dynamic sql

   #{x} in dynamic sql is from two source, one is get("x") method, another is getX(), get("x") is high priority.

   <if test="<condition>"> <sentence></if>, add sentence when test condition return true

   <choose>

   <where test="<condition"></where> can handle where and and nicely

   <set> can handle set and , nicely

   <foreach>, iterate over collection

** setting

   - <properties> set property key value

   - <typeAliases> set type aliases

   - <typeHandler> is used to convert between sql data and java object, there are some general typeHandler, 

     EnumTypeHandler is used for convert bettwen enum and int

   - <objectFactory> used to from sql data to build java object, can extend from DefaultObjectFactory

   - <setting name="logIml" value="STDOUT_LOGGING"/> let logback print out sql

* Elastic Search

  bin/elasticsearch start es, default listen port is 9200

  bin/plugin -i, install plugin

  document is index/search base unit

  structure: indices(database) -> types(table) -> document(row) -> field(column)

  filter like where, aggregation like group

  shard is basic data unit, one index include multiple shard, only exist one primary shard, exist zero to many replica shard

  primary shard is decide when start up, can't changed, replica shard can change, search will get data from primary and replica together

  unassigned_shard is shart that not assigned to node

** http api

   - Get to query data

   - Put to insert data

   - url patten is <index>/<type>/<id>

   - <location>/_search?q=<condition> or POST <location>/_search pass query condition to query data

   - q=<value> means equal, q=-<value> means not equal 

   - _shutdown, shutdown es

   - _plugin/<plugin name> access plugin

   - _cluster/health get cluster health info

   - put /index 

     {

     "settings": {

     "number_of_shards": <num>,

     "number_of_replicas":  <num>

     }

     }

     change index shard setting

* Concurrency
  Thread = Cpu Number * Cpu target usage * (1 + (Wait time / compute Time))

  daemon thread will not prevent program exit, non daemon thread will stop program exit until it execute done

  mutable is program misfunction root cause on concurrency program

  count++ is race condition, also is data race

  race condition general case is check-then-act or read-modify-write, when you get some value then do something, maybe system state already changed

  static method use class object as lock object

  if need protect a class multiple mutable field, should use same lock to protect together, let them as a atomic operation

  concurrency should solve two sub-problem, one is atomic, another is visibility

  64 bit operate is not atomic, use volatile can ensure atomic

  lock ensure atomic and visibility

  volatile let variable can't be re-order, can't be cache, visibility to all thread

  volatile only suit those scenarios

  1. write a variable not depend on current value

  2. only one thread to write this variable, this variable is not a part of ensure object is same

  walk on a object can reach field means is public, pass a object to a method also means public this object, public a internal object means public it outside object

  don't public `this` on constructor, general case is create thread on constructor

  Thread Confinement, keep a object only exist on one thread, it ensure thread safe.

  Thread local object, when thread first call get method, initialValue will be called

  Immutable object always thread safe.

  safe publish object way:

  1) static field initial a object

  2) use volatile or AtomicReference

  3) final field save initialed object

  4) use lock to publish object

  5) thread safe collection to publish

  static field publish object is easiest, jvm mechanism ensure this

  use private object to as lock avoid activity problem

  an object has multiple field, use separate thread safe collection to ensure every field can make object safe if every field is independent

  add new opeartor on already thread safe object, best way is use composition and antoher lock to ensure thread safe

  if document not declare it is thread safe, means it is not thread safe

  when use iterator on thread safe collection, will record a count, if count change, any then getNext and hasNext will throw ConcurrentMOdificationException

  collection toString, xxAll, hasCode maybe use iterator

  Queue is add after 5.0, purpose is improve performance when random access, BlockingQueue is good choice to implement producer/consumer strategy

  Executor object has kinds of method to create ExecutorSerivce, ExecutorService is kinds of strategy to re-use threads
  ScheduleExectorService can schedule task after some delay

* Spring

  spring core is IoC and AOP

  IoC is let container maintain object lifecycle

** IOC

   two initial way:

   1. BeanFactory only IoC, initialize lazy

   2. ApplicationContext, extend from BeanFactory, support AOP, egar initialize

   bean initialize way:

   1. default constructor

   2. factory-method set initialize method of this class static method

   3. set factory-bean and factory-method

   4. <constructor-arg>, can set by type, by index or by name

   cycle depedency will throw BeanCurrentlyInCreationException

   constructor:

   <null/> use to set null

   depende-on set the class will initialize after depende-on class

   @autowire inject by name or by type, if same type has multiple instance, throw exception

   lifecycle:

   - singleton

   - prototype, multiple instance

   - request, one request one instance

   - session

   - application

** AOP

   <aop: scoped-proxy proxy-target-class="false"> set base on interface proxy

   @Around to implement aop, method accept a ProceedingJoinPoint return method execute result
   @Around("@annotation(<annotation name>)") around cut on which method has annotation

   @Aspect enable annotation based aop

** Spring mvc
   two container:

   - tomcat ContextLoaderListener, this class will initialize WebAppicationContext,

     keep DAO and service, then register a DispatcherServlet, this class will read

     <servlet-name>-servlet.xml then construct the second container

   - the second container's parent is above container, so can read service and dao

     instance, incluse HanlderMapping(for http), HandlerAdapter, ModelAndView is

     use to response, ViewResolver is to find view.

   three implement method:

   - implement HttpRequestHandler then override handleRequest, then register on

     second on container

   - extend AbstractController, implement RequestInternal method, return ModelAndView

   - use @Controller on class, @RequestMapping on Method then return ModelAndView, @RequestParam bind

     parameter from request, @RequestHeader get Header value, @CookieValue get coockie, @RequestBody

     @PathVariable get url path, @ResponseBody custom response format

   extend HandlerExceptionResolver then implement resolveExcpeiton then register in container to handle global exception

   HandlerInterceptor intercept request before handle, after handle then after view resolve

   <welcome-file-list> set 404 error page

   @ControllerAdvice use HandlerInterceptor to handle all controller exception, then use @ExceptionHandler set handle Exception method
   
   server.error.whitelabel.enabled=false disable whiteabel page, let tomcat return 404

   @Controller then implement ErrorController override getErrorPath to return custom 404 page

   @ModelAttribute, execute before RequestMapping, general used on common property for model

*** HandlerInterceptor vs Filter
    HandlerInterceptor is basically similar to a Servlet 2.3 Filter, but in contrast to the latter it just allows custom pre-processing with the option of prohibiting the execution of the handler itself, and custom post-processing. Filters are more powerful, for example they allow for exchanging the request and response objects that are handed down the chain. Note that a filter gets configured in web.xml, a HandlerInterceptor in the application context.
    As a basic guideline, fine-grained handler-related preprocessing tasks are candidates for HandlerInterceptor implementations, especially factored-out common handler code and authorization checks. On the other hand, a Filter is well-suited for request content and view content handling, like multipart forms and GZIP compression. This typically shows when one needs to map the filter to certain content types (e.g. images), or to all requests.
** configuration

   legacy way is xml config file

* Spring Boot
  four core tricks:
  - Automatic configuration
  - Starter dependencies
  - Command-line interface
  - Actuator
  [[https://start.spring.io]] spring initlizer web version
  SpringApplication.run() let application can run from a jar file, e.g. gradle bootRun, mvn spring-boot:run
** Install
   [[https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html]]
** Cli
   spring run <groovy file>
   spring init -d<dependency1>,<dependency2>... --build <maven or gradle> -p <jar or war>
** Annotation
   @SpringBootApplication combine three other annotation:
   - @Configuration, designates a class as a configuration class use java-based configuration
   - @ComponentScan, enables component-scanning so that web controller classed and other component automatically discovered and registered
   - @EnableAutoConfiguration, enable magic of spring boot auto-configuration
   @ConfigurationProperties, inject property to this instance field with prefix
** Properties
   server.port, controll web application listen port
** Auto Configuration
   AutoConfigration is based on Conditional Configuration, inroduced in Spring 4.0
   Condition class implmement Condition or SpringBootCondition
   | @Conditional                    | the class matches return true                                                      |
   | @ConditionOnBean                | the specified bean has been configured                                             |
   | @ConditionalOnMissingBean       | the specified bean has not already bean configured                                 |
   | @ConditionOnClass               | the specified class is availabel on the classpath                                  |
   | @ConditionalOnMissingClass      | the specified class is not available on the classpath                              |
   | @ConditionalOnExpression        | the given Spring Expression Language (SpEL) expression evaluates to true           |
   | @ConditionOnJava                | the version of java matches a specific value or range of version                   |
   | @ConditionalOnJndi              | there is a JNDI InitialContext available and optionally given JNDI locations exist |
   | @ConditionalOnProperty          | the specified configuration property has a specific value                          |
   | @ConditionalOnResource          | the specified resource is availabel on the classpath                               |
   | @ConditionalOnWebApplication    | the application is a web application                                               |
   | @ConditionalOnNotWebApplication | the application is not a web application                                           |
   spring boot is load application-level configuration before considering auto-configuration class
   provide self config bean to override auto config
   auto config support externalizing configuration to tweak partial config:
   - Command-line arguments
   - JNDI aatributes from java:comp/env
   - JVM system properties
   - Opreation SYstem environment variables
   - Randomly generated values for peroperties prefixed with random.*
   - An application.properties or application.yml file outsiw of the application
   - An application.properties or application.yml packaged inside of the application
   - Property sources specified by @PropertySource
   - Default properties
   property order of precendence:
   1. Externally, in a /config subdirectory of the directory from which the application is run
   2. Externally, in the directory from which the application is run
   3. Internally, in a packaged named "config"
   4. Internally, at the root of the classpath
* Servlet

** Lifecycle

   The servlet is initialized by calling the init() method. only called once

   The servlet calls service() method to process a client request, every request will call this method

   The servlet is terminated by calling the destroy() method. only called once

   Finally, servlet is collected by the garbage collector of the JVM.

** how run

   put compiled servlet class file on webapps/ROOT/WEB-INF/classed directory with same class package name,

   then modify web.xml, <servlet> mapping to class name, <servlet-mapping> mapping to url address

** parameter

   use getParameter of class HttpServletRequest to get parameter(Get, Post),

   getParamterNames get all name, getParamterValues get all value

   HttpServletResponse to response to client

   getCookies() get cookie

   getSession() get or create session

** url match pattern

   - full path

   - partial path

   - extension

   - default

** filter

   filter will execute before servlet, filter order is declare order in xml config

** listener

   listener will execute when some event is trigger

* Guava

** MultiSet and MultiMap

   used count, find duplicate

** Iterators

   support pipe operator, sort, inverse, find, statistics

** ForwardingList

   implement delegate method, then every method will execute on delegate return object

** PeekingIterator

   can access next element after current, will cause iterator go to next, next access direct use previous cache field 

** AbstractIterator

   need implement computerNext(), return what your want return, can used as filter function

** AbstractSequential

   like functional stream

** LaodingCache

   get() used to access no exception value, getUnchecked() access maybe throw exception, loadAll load multiple value

** Cache

   base on time or capacity or reference type eviction

* Maven

  finalName is used to set build out jar fileName, default format is <artifactId>-<version>

  exclusion set some package dont import

  dependenciesManager set this and child pom dependency version, but not import, then import those dependency can omit version

** depedency scope

   - compile: compile and runtime

   - test: test

   - provided: compile and test

   - runtime: test and runtime

   - system: compile and test(use systemPath to locate)

   - import

** lifecycle

*** clean

    - preclean

    - clean

    - post clean

*** default

    - process-sources

    - compile

    - process-test-sources

    - test-compile

    - test

    - package

    - install

    - deploy

*** site

    - pre-site

    - post-site

    - site-deploy

** parent and child

   relativePath set parent pom location

   parent pom use dependenciesManager set global depedency version, not import any package

** command argument

   -pl: xx only build this module

   -am also build depedency module

   -amd build dependency module child module

   -rf set some module dont build

   -DskipTests skip test

   -Dtest=xx 

* substring

** 1.6

   base is a array, substring return new object but point to same array with different offset

   but maybe cause memory leak, like substring from multiple big string only use a little part

** 1.7

   copy array

* Basic

  object head is 16 bytes

  array head is 24 bytes

  one char is 2 byte

  Serilizable only implement this class can serilize, don't need implement any thing. The real

  implement method is defaultReadObject/readObject of class ObjectOutputStream/ObjectInputStream,

  if class implement writeObject/readObject, then use those implements. SerilizalVersionUID use to demonstrate

  the class is same class, static field can't be serilize, @Transient will not be write out, set to default value when deserilize

  try catch finally, if finally contain return, will use finally return as final value

* debug

  JAVA_OPTS or CATALINA_OPTS add -agentlib:jdwp=transport=db_socket,server=y,suspend=n,address=<port> to enable remote debug

  javap, is decompile tool, -c decompile to bytecode

* jvm  

  java 9, java.lang.ref.Reference.reachabilityFence(Object ref), assure ref is reachable on this location

* keytool
  #+BEGIN_SRC bash
keytool -genkey -alias <name> -keyalg RAS -keystore <filename.jks> -keysize 2048 -validity 360 -dnma CN=<domain> -keypass <password> -sotrepass <password> # generate jks file

keytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA256 -keysize 2048 -alias HS256 -keypass secret
keytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA384 -keysize 2048 -alias HS384 -keypass secret
keytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA512 -keysize 2048 -alias HS512 -keypass secret
keytool -genkey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg RSA -keysize 2048 -alias RS256 -keypass secret -sigalg SHA256withRSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg RSA -keysize 2048 -alias RS384 -keypass secret -sigalg SHA384withRSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg RSA -keysize 2048 -alias RS512 -keypass secret -sigalg SHA512withRSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkeypair -keystore keystore.jceks -storetype jceks -storepass secret -keyalg EC -keysize 256 -alias ES256 -keypass secret -sigalg SHA256withECDSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkeypair -keystore keystore.jceks -storetype jceks -storepass secret -keyalg EC -keysize 256 -alias ES384 -keypass secret -sigalg SHA384withECDSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360
keytool -genkeypair -keystore keystore.jceks -storetype jceks -storepass secret -keyalg EC -keysize 256 -alias ES512 -keypass secret -sigalg SHA512withECDSA -dname "CN=,OU=,O=,L=,ST=,C=" -validity 360

  #+END_SRC
* shiro  
  SecurityManager is authentication/authorization entry point
  SecurityManager contain multiple realms
  Realm extend AuthorizingRealm then override doGetAuthrizationInfo()  doGetAuthenticationInfo()
  SecureRandomNumberGenerator() used to generate salt
  SimpleHash(algorithm, password, salt, times) generate encrypt password
** ini config
*** config file format
    [users]
    <username> = <password>, <role>
    [roles]
    <role> = <permission1>, <permission2>
*** use config file
    #+BEGIN_SRC java
    Factory<SecurityManager> factory = new IniSecurityManagerFactor("init config file");
    SecurityManager sm = factory.getInstance();
    SecurityUtils.setSecurityManager(sm);
    Subject subject = SecurityUtils.getSubject();
    UsernamePasswordToken token = new UsernamePassword(user.getName(), user.getPassword());
    try {
        subject.login(token);
    } catch (AuthenticationException e) {
        // login failed
    }
    subject.hasRole("some role");
    subject.isPermitted("some permission");
    subject.isAUthenticated(); // is user authentication
    subject.logout();
    #+END_SRC
** database config
*** cofnig file format
    [main]
    databaseRealm=<realm class full name>
    securityManager.realms=$databaseRealm
*** config code
**** doGetAuthenticationInfo
     if success, return SimpleAUthenticationInfo
     if error, throw AuthenticationException()
**** doGetAuthrizationInfo
     if success, set SimpleAuthorizationInfo permissions and roles
** encrypt password   
*** config file format
    [main]
    credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher
    credentialsMatcher.hashAlgorithmName=<algorithm>
    credentialsMatcher.hashIterations=<iteration>
    credentialsMatcher.storedCredentialsHexEncoded=true

    databaseRealm=<realm calss full name>
    securityManager.realms=$databaseRealm
*** config code
    return SimpleAuthenticationInfo(userName,passwordInDB,ByteSource.Util.bytes(salt),getName())
** servlet
*** config file format
    [main]  
    databaseRealm=com.how2java.DatabaseRealm
    securityManager.realms=$databaseRealm
    # if not authenticate, will direct this page
    authc.loginUrl=/login.jsp
    # no role
    roles.unauthorizedUrl=/noRoles.jsp
    # no perms
    perms.unauthorizedUrl=/noPerms.jsp
    [urls]  
    /doLogout=logout
    # allow anonymous access url
    /login.jsp=anon
    /noroles.jsp=anon
    /noperms.jsp=anon
    # need role/permission url
    /listProduct.jsp=authc  
    /deleteProduct.jsp=authc,roles[productManager]  
    /deleteOrder.jsp=authc,perms["deleteOrder"]   


*** web.xml
    #+BEGIN_SRC xml
<web-app>
    <listener>
        <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
    </listener>
    <context-param>
        <param-name>shiroEnvironmentClass</param-name>
        <param-value>org.apache.shiro.web.env.IniWebEnvironment</param-value><!-- 默认先从/WEB-INF/shiro.ini，如果没有找classpath:shiro.ini -->
    </context-param>
    <context-param>
        <param-name>shiroConfigLocations</param-name>
        <param-value>classpath:shiro.ini</param-value>
    </context-param>
    <filter>
        <filter-name>shiroFilter</filter-name>
        <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>shiroFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
</web-app>
    #+END_SRC
** Spring MVC
*** web.xml
    #+BEGIN_SRC xml
  <filter>
    <filter-name>shiroFilter</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    <init-param>
      <param-name>targetFilterLifecycle</param-name>
      <param-value>true</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>shiroFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>	
    #+END_SRC
*** applicationContext-shiro.xml
    #+BEGIN_SRC xml
  <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
    <property name="securityManager" ref="securityManager" />
    <property name="loginUrl" value="/login" />
    <property name="unauthorizedUrl" value="/unauthorized" />
    <property name="filters">
      <util:map>
        <entry key="logout" value-ref="logoutFilter" />
      </util:map>
    </property>
    <property name="filterChainDefinitions">
      <value>
        /login=anon
        /index=anon
        /static/**=anon
        /doLogout=logout
        /** = authc
      </value>
    </property>
  </bean>
  <bean id="logoutFilter" class="org.apache.shiro.web.filter.authc.LogoutFilter">
    <property name="redirectUrl" value="/index" />
  </bean>

  <bean id="sessionIdGenerator"
    class="org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator" />
  <bean id="sessionIdCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
    <constructor-arg value="sid" />
    <property name="httpOnly" value="true" />
    <property name="maxAge" value="-1" />
  </bean>
  <bean id="sessionDAO"
    class="org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO">
    <property name="sessionIdGenerator" ref="sessionIdGenerator" />
  </bean>
  <bean name="sessionValidationScheduler"
    class="org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler">
    <property name="interval" value="1800000" />
    <property name="sessionManager" ref="sessionManager" />
  </bean>
  <bean id="sessionManager"
    class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
    <property name="globalSessionTimeout" value="1800000" />
    <property name="deleteInvalidSessions" value="true" />
    <property name="sessionValidationSchedulerEnabled" value="true" />
    <property name="sessionValidationScheduler" ref="sessionValidationScheduler" />
    <property name="sessionDAO" ref="sessionDAO" />
    <property name="sessionIdCookieEnabled" value="true" />
    <property name="sessionIdCookie" ref="sessionIdCookie" />
  </bean>

  <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
    <property name="realm" ref="databaseRealm" />
    <property name="sessionManager" ref="sessionManager" />
  </bean>
  <bean
    class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
    <property name="staticMethod"
      value="org.apache.shiro.SecurityUtils.setSecurityManager" />
    <property name="arguments" ref="securityManager" />
  </bean>

  <bean id="databaseRealm" class="com.how2java.realm.DatabaseRealm">
    </bean>
    
  <bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor" />
    #+END_SRC 

** Spring boot
   enable @Configuration then provide a Realm Bean and a ShiroFilterChainDefinition Bean
* java 8 9 11
** lambda
   only a abstract method interface is function interface
   lambda can pass to require function interface location
   @FunctionalInterface is not required, but add it is a good practice, it will check is this interface is a functional interface
   java8 add out-of-box functional interface
   | functional interface | syntax schema     |
   | Predicate<T>         | T -> boolean      |
   | Consumer<T>          | T -> void         |
   | Function<T,R>        | T -> R            |
   | Supplier<T>          | () -> T           |
   | UnaryOperator<T>     | T -> T            |
   | BinaryOperator<T>    | (T, T) -> T       |
   | BiPredicate<T, U>    | (T, U) -> boolean |
   | BiConsumer<T, U>     | (T, U) -> void    |
   | BiFunction<T, U, R>  | (T, U) -> R       |
   java8 add like IntPredicate to avoid boxing/unboxing
   lambda body return void is a special case handle by language specification
   method reference, use :: syntax to reference exist method as lambda
   java8 interface support default method, java8 functional interface include some help method to build function,
   comparator: reversed(), comparing, then compare
   predicate: negate() and() or()
   function: andThen() compose()
** stream
   intermidiate opration return another stream, don't perform any processing until a terminal opreation(lazy), it's good for optimization, e.g filter map limit sorted distinct
   terminal operation, e.g collect reduce forEach count
   stream can only traversed once
   there are IntStream DoubleStream LongStream for avoid boxing/unboxing, mapToInt mapToDouble mapToLong
   boxed() convert a primative stream to a boxed stream
   IntStream.rangeClosed() IntStream.range() generate int stream
   Stream.of() create stream from element, Stream.empty() create empty stream, Stream.ofNullable() create stream and ignore null element
   Arrays.stream() create stream from array
   java8 nio support create stream from file
   Stream.iterate, generate infinite stream by a start value and a iterate function
   Stream.generate, generate infinite stream by Supplier<T>
*** operator
    - filter
    - takeWhile(java9) dropWhile(java9) limit skip
    - map flatMap
    - allMatch anyMatch noneMatch findFirst findAny
    - reduce count sorted forEach collect
    - mapToInt mapToDouble mapToLong mapToObj
*** Collector
    Collector is more generate reduce
    - counting
    - maxBy minBy
    - summingInt summingDouble summingLong
    - averagingInt
    - summarizingInt
    - join
    - reducing
    - groupingBy
    - mapping
    - flatMapping
    - collectingAndThen
    - partitioningBy
    - toList
    - toSet
    - toCollection
*** parallel
    parallelStream create parallel stream from collection
    parrallel() change a stream to parallel stream
    sequential() change a parallel stream into a sequential stream
    Parallel stream internally use default ForkJoinPool to execute, default has as many threads as you have processors
    Spliterator is add from java 8
    StreamSupport.stream(splitor, true) create stream from customer Spliterator
** Collecttion
*** List Set
    List.of create immutable list
    Set.of create immutable set, if element duplicate throw IllegalArgumentException
    removeIf, work on Set and List, pass a lambda to modify collection 
    replaceAll, work on List, pass a lambda to replace element
*** Map
    Map.of(k1,v1 ...) create immutable map
    Map.ofEntries(Map.entry(k,v) ...) create immutable map
    forEach forEachOrdered
    Entry.comparingByValue Entry.comparingByKey
    getOrDefault
    computeIfAbsent, if key not exist, will call second argument get result then put key and result to map
    computeIfPresent, if key exist, compute new value replace, if new value is null the key is removed
    compute
    remove(key,value), only key and value both match then remove
    removeIf
    replaceAll, replace each entry with apply a BiFunction
    replace, replace a value if key is present
    merge(k,v, bifunction) merge key/value to map with merge value function
*** ConcurrentHashMap
    forEach
    reduce
    search, applie function on each key/value until produce non-null result
    mappingCount
** Optional
   Optional.empty() Optional.of() Optional.ofNullable() create Optional
   map flatMap filter
   stream() convert optional to stream
   get() orElse(T) orElseGet(Supplier<? extends T>) or(Supplier <? extends Optinal<? extends T>>) orElseThrow ifPresent(Consumer)  ifPresentOrElse(Consumer, Runnbale)
   avoid use OptionalInt OptionalLong OptionalDouble because these lack map flatMap and filter function
** Date
   package java.time include new design time related class
   LocalDate and LocalTime not care about timezone
   java.time.temporal contain kinds of Temporal Field used on get method param
*** LocalDate
    LocalDate.of(year, month, day) create LocalDate
    LocalDate.now()
    LocalDate.parse()
    getYear getMonth getDayOfMonth getDayOfWeek lengthOfMonth isLeapYear
    withXX method create new LocalDate without mutable exist one
    plusXX minusXX
*** LocalTime
    LocalTime.of(hour, minute, second)
    LocalTime.now()
    LocalTime.parse()
    getHour getMinute getSecond
*** LocalDateTime
    LocalDateTime is combine LocalDate and LocalTime
    LocalDateTime.of()
    LocalDateTime.of(date, time)
    date.atTime
    time.atDate
    toLocalDate toLocalTime
*** Instant
    instant is represent time from unix epoch time (1970,1,1 00:00:00 UTC)
    Instant.ofEpochSecond(second, nanoSecond adjust)
    Instant is used by machine, so it not support ge human readable time unit, like day of month
*** Duration Period
    Duration.between, create duration from two Temporal instance(LocalData, LocalTime... implement this interface)
    Duration can't used with mix Instant and LocalXX
    Duration is for get second/nano second, so not support LocalDate
    Period.between, get day/month/year duration of to date
    Duration and Period has other way create, e.g. Duration.ofMinutes
*** TemporalAdjuster
    advanced time adjust, e.g nextOrSame lastDayOfMonth
    | method              | description                                                                                                                       |
    | dayOfWeekInMonth    | Creates a new date in the same month with the ordinal day of week. (Neg- ative numbers count backward from the end of the month.) |
    | firstDayOfMonth     | Creates a new date set to the first day of the current month.                                                                     |
    | firstDayOfNextMonth | Creates a new date set to the first day of the next month.                                                                        |
    | firstDayOfNextYear  | Creates a new date set to the first day of the next year.                                                                         |
    | firstDayOfYear      | Creates a new date set to the first day of the current year.                                                                      |
    | firstInMonth        | Creates a new date in the same month with the first matching day of the week.                                                     |
    | lastDayOfMonth      | Creates a new date set to the last day of the current month.                                                                      |
    | lastDayOfNextMonth  | Creates a new date set to the last day of the next month.                                                                         |
    | lastDayOfNextYear   | Creates a new date set to the last day of the next year.                                                                          |
    | lastDayOfYear       | Creates a new date set to the last day of the current year.                                                                       |
    | lastInMonth         | Creates a new date in the same month with the last matching day of the week.                                                      |
*** DateTimeFormatter
    formatting and parsing time
    xx(instance).format
    xx(class).parse
    DateTimeFormatter is thread safe
    DateTimeFormatter.ofPattern create DateTimeFormatter from pattern
*** TimeZone
    java.time.ZoneId replace java.util.TimeZone
    ZoneId.of get TimeZone
    xx.atStartOfDay(ZoneId)  xx.atZone(Zone)
    xx.toInstance(ZoneId) convert LocalDate/Time/DateTime to Instant
    xx.ofInstant(Zone) convert Instant to LocalDate/Time/DateTime
    ZoneOffset.of  create offset from UTC, then use OffsetDateTime.of create date from offset

** Default method
   from java8, interface method can has a implement body
   from java8, interface can has static method
   default is keyword
   interface with default method is different with abstract class:
   - interface can implement from multiple
   - interface can't has a instance variable
   default method conflict resolve rules:
   1. classes always win
   2. otherwise, subinnterfaces win
   3. explicity select (use X.super.xx syntax)
** Module System
   Java9 add module system, from project Jigsaw
   module-info.java is module info
   any jar firl bot been module will auto be a module, automatic modules implicity export all their package, module name is jar name without version
*** syntax
    module <module-name> {
      requires <module-names>
      exports <package-names>
      requires transitive <module-name> // require module, then another module require this module will get require transitive module packages
      exports <package> to <package>
      opens-to <package> // allow reflection
    }
    open module <module-name>, has no effect on module visibility except for allowing reflective access
    after java9, reflection is no longer allow by default, the open clause is allow this
** CompletableFuture
   Future is introduce on java 5, java 8 introduce CompletableFuture make it composable
   CompletableFuture<V> thenCombine(CompletableFuture<U> other, BiFunction<T,U,V> fn)
   CompletableFuture<U> thenApply(Function<T, U>fn)
   CompletableFuture<U> thenCompose(Function<T, CompletionStage<U>> fn), execute fn use same thread with origin CompletableFuture
   CompletableFuture<U> thenComposeAsync(Function<T, CompletionStage<U>> fn), execute fn use new thread
   CompletableFuture<Void> thenAccept(Consumer<? super T> action)
   <instance>.complete(<data>) <intance>.completeExceptionlly(<exception)
   CompletableFuture.supplyAsync(Supplier<T>), is handy way combine complete and completeExceptionlly, default exectute in default ForkJoinPool
   join is simalar with get, but join not throw checked exception, all exception convert to unchecked exception
   CompletableFuture factory method support pass customer Executor
   CompletableFuture.allOf(<future array>), create a CompletableFuture<Void> from all futures
   CompletableFuture.anyOf(<future array>), create a CompletableFuture<Object> complete with first-to-complete rule
   <instance>.orTimeOut(<time>, <unit>)
   <instance>.completeOnTimeOut(<value>, <time>, <unit>)
** Flow
   added in java 9, under package java.util.concurrent.Flow, for stream like reactive programming, known as the publich-subscribe model
   Flow use request implement backpressure, change model from push to pull
   Flow implmement Reactive Streams(www.reactive-streams.org) required feature, akka Reactor RxJava Vert.x also share same specification
   Flow cotnain 4 nested interface:
   - Publisher
   - Subscriber
   - Subscription
   - Processor
   Subscriber event strictly following the sequence: onSubscribe onNext* (onError | onComplete)?
   Flow is interface definition, java not prodide implmement, it should implmement by 3rd lib, e.g Akka RxJava
** Annotation
   annotation enchanved in java 8 by two ways:
   - repeat annoations
   - annotate any type uses
   let annotation repeateable, first annoated annotate with @Repeatable, second provide a container e.g. @interface Author {} @interface Authors {Author[] value;}
** Array
   praalelSort setAll parallelSetAll parrallelPrefix
** Number and Math
   min max sum
   compareUnsigned divideUnsigned remainderUnsigned toUnsignedString
   parseUnsignedInt parseUnsignedLong
   isFinite
   logicalAnd logicalOr logicalXor
   addExtra subtractExtract
** Files
   Files.list, produce a stream<Path>, isn't recusive
   Files.walk, like Files.list but is recursive and can control depth level
   Files.find, produce a Stream<path> from recursive traversing a directory to find entries that match given predicate
* Library
** Java Microbeanchmark Harness(JMH) 
   is a toolkit that helps to create, in a simple, annotation-based way, reliable microbenchmarks for Java programs and for any other language targeting the Java Virtual Machine (JVM)
* RxJava
  <instance>.blockingSubscribe(Observer<T> ob) execute ob on current thread
  support map, filter, merge, combine ... method
** Observable
   Observable, non backpressure version Flow
   Observable.just(<elements>), create Observer then emit onNext* onComplete event
   Observable.interval(<time>, <unit>) period generate event
   Observable.create(ObservableOnSubscribe) create Observable from lambda
** Flowable
  Flowable, backpressure version Flow
** Observer
   #+BEGIN_SRC java
   public interface Observer<T> {
     void onSubscribe(Disposable d);
     void onNext(T t);
     void onError(Throwable t);
     void onComplete();
   }
   #+END_SRC
   define simalar as java Flow.Subscriber interface
   
  

* basic
  in .lhs file, default is comment, > (space here) follow is code

  in .hs file, default is code, -- is comment for one line, {- <content> -} is comment for region

  Int range is decide by ghc version and opeartion system

  Integer length only limit by memory, more expensive than Int

  numberic literal:
  - 0b, binary
  - 0o, octal
  - 0x, hex

  ^ is interger exponentiation, ** is number exponentiation

  function is highest precedence opeartion(10), call is left associate, define type is right associate

  <x> = <y>, define x is value of y

  function definition must start with lower case

  [] is List type and List literal constructor, element type must consistent

  'a' is char, "ab" is string and euqal to ['a','b']

  [<from>..<until>], generate a list from <from> to <until>, omit until to get infinity list

  [<from>,<second element>..<until>], generate list from <from> to <until> with same step as <second element>, omit until to get infinity list

  () is Tuple type and literal constructor

  :: used to decleration varaible/function/expression type

  <typeclass a> =>, means class constraint, multiple constraint seperate by comma(,)

  function can define with multiple line, pattern match is on write order

  <function name> <arg> | <condition>, pattern guard

  let <bindings> in <body>

  <body> where <bindings>

  case <xx> of <yy> -> <expression>

  if <condition> then <true body> else <false body>

  haskell function only has one parameter, every function is curried

  \<arg> -> <body>, literal lambda

  module is haskell modular unit, module include data/class/function, module must start with upper case char, and module need same as file name

  import:
  - import <xx>, import module xx
  - import <xx> (<yy>), import module xx's yy element
  - import <xx> hiding (<yy>), import module xx but hiding element yy
  - import qualified <xx>, must use full name to use this module
  - import <xx> as <yy>, use <yy> name import <xx> module

  module <module name>(<elements>) where, used to expose module, if omit <elements> means export nothing

  data is keyword to create new type, format data <Name> [type variable] = <Constructor1> .. | <Constructor2> .. | .., <Name> is type name, must start with upper case, <Constructor> is constructor, must start with upper case, constructor is alos a pattern matching deconstructor

  data A = A {x :: Int}, named field, constructor by A <x>, and has a field access function x :: A -> Int

  type constructor and name construcor is on different namespace

  typeclass constraint should on function, not on data definition

  type <alias> = <value>, given <value> a alais 

  _ is generic placeholder

  haskell use indent to control expression, empty line and more right indent trade as a same expression with previous line, same indent means a new expression block.

  if don't use indent, use comma(,) and brace({}) to control expression block

  do is syntax sugar for Monad 

  `(backquotes) used enclose function to a infix operation

  do not use length when other function is better, e.g. isEmpty better than > 0 . length

  foldl on large input will stack overflow, because lazy calculate, use foldl' force evaluate

  partial apply function, only support part of arguments to function, e.g (*2)

  @ is used in pattern match, e.g xs@(y:ys)

  split pure and non pure code

  undefined is a placehodler, can be any type, evaluate will throw exception

  newtype is similar as data, but newtype can only have one constructor and constructor only has one parameter, it only exist in compile time, no any impact on runtime
* Lazy
  error seq usage:
  - someFunc (x `seq` y), x evaluate until someFunc evaluate
  - let a = x `seq` y in someFunc a is same
  - (1+2):(3+4):[], only (1+2) will be evaluate
  - ((1+2), (3+4)), only evaluate to pair, inner evaluate not execute
  seq is evalute on runtime, maybe cause performance issue
   
* Language Extension

  ParallelListComp, allow use syntax [(x,y)| x <- xs | y <- ys], in fact it xs and ys zip

  ApplicativeDo, allow Functor, Applicative use do syantax

* typeclass
  typeclass similar to interface
  define a typeclass
  #+BEGIN_SRC haskell
  class <Name> <type variables> where
    <func1> ..
    <func2> ..
  #+END_SRC
  define a typeclass instance
  #+BEGIN_SRC haskell
  instance <Name> <actual type> where
    <implmenets>
  #+END_SRC
** Show
   type ShowS = String -> String
*** Definition
    #+BEGIN_SRC haskell
    class Show a where
      showsPrec :: Int -> a -> ShowS
      show :: a -> String
    #+END_SRC
*** API
    #+BEGIN_SRC haskell
    showString :: String -> ShowS
    showChar :: Char -> ShowS
    shows :: (Show a) => a -> ShowS
    #+END_SRC
** Eq
*** Definition
    #+BEGIN_SRC haskell
    class Eq a where
      (==) :: a -> a -> Bool
      (/=) :: a -> a -> Bool
    #+END_SRC
** Ord
*** Definition
    #+BEGIN_SRC haskell
    class Eq a => Ord a where
      compare :: a -> a -> Ordering
      (<) :: a -> a -> Bool
      (<=) :: a -> a -> Bool
      (>) :: a -> a -> Bool
      (>=) :: a -> a -> Bool
      max :: a -> a -> a
      min :: a -> a -> a
    #+END_SRC

** Enum  
*** Definition
    #+BEGIN_SRC haskell
    class Enum a where
      succ :: a -> a
      pred :: a -> a
      toEnum :: Int -> a
      fromEnum :: a -> Int
      enumFrom :: a -> [a]
      enumFromThen:: a -> a -> [a]
      enumFromTo :: a -> a -> [a]
      enumFromThenTo :: a -> a -> a -> [a]
    #+END_SRC
** Bounded
*** Definition
    #+BEGIN_SRC haskell
    class Bounded a where
      minBound :: a
      maxBound :: a
    #+END_SRC
** Num
   all number base
*** Definition
    #+BEGIN_SRC haskell
    class Num a where
      (+) :: a -> a -> a
      (-) :: a -> a -> a
      (*) :: a -> a -> a
      negate :: a -> a
      abs :: a -> a
      signum :: a -> a
      fromInteger :: Integer -> a
    #+END_SRC
** Integral
   Integral number base
*** Definition
    #+BEGIN_SRC haskell
    class (Real a, Enum a) => Integral a where
      quot :: a -> a -> a
      rem :: a -> a -> a
      div :: a -> a -> a
      mod :: a -> a -> a
      quotRem :: a -> a -> (a, a)
      divMod :: a -> a -> (a, a)
      toInteger :: a -> Integer
    #+END_SRC
** Floating
*** Definition
    #+BEGIN_SRC haskell
    class Fractional a => Floating a where
      pi :: a
      exp :: a -> a
      log :: a -> a
      sqrt :: a -> a
      (**) :: a -> a -> a
      logBase :: a -> a -> a
      sin :: a -> a
      cos :: a -> a
      tan :: a -> a
      asin :: a -> a
      acos :: a -> a
      atan :: a -> a
      sinh :: a -> a
      cosh :: a -> a
      tanh :: a -> a
      asinh :: a -> a
      acosh :: a -> a
      atanh :: a -> a
      GHC.Float.log1p :: a -> a
      GHC.Float.expm1 :: a -> a
      GHC.Float.log1pexp :: a -> a
      GHC.Float.log1mexp :: a -> a
    #+END_SRC
** Functor
*** Definition
    #+BEGIN_SRC haskell
   class Functor f where
     fmap :: (a -> b) -> f a -> f b
    #+END_SRC
*** API
    #+BEGIN_SRC haskell
   void :: (Functor f) -> f a -> f ()
    #+END_SRC
** Applicative
*** Definition
    #+BEGIN_SRC haskell
   class Pointed f where
     point :: a -> f a

   class (Pointed f, Functor f) => Applicative f where
     pure :: a -> f a
     (<*>) :: f (a -> b) -> f a -> f b
     pure = point
    #+END_SRC
*** Implmenet Functor
    #+BEGIN_SRC haskell
   fmap :: (Applicative f) => (a -> b) -> f a -> f b
   fmap f fa = (pure f) <*> fa
    #+END_SRC
*** API
    #+BEGIN_SRC haskell
    forever :: Applicative m => m a -> m b
    when :: Applicative m => Bool -> m () -> m () -- when condition is true, execute second arg else return ()
    unless :: Applicative m => Bool -> m () -> m ()
    #+END_SRC 
** Monad
*** Definition
    #+BEGIN_SRC haskell
   class Applicative m => Monad m where
     return :: a -> m a
     join :: m (m a) -> m a
     (>>=) :: m a -> (a -> m b) -> m b
     (>>) :: m a -> m b -> m b
     return = pure
     join mma = mma >>= id
     (>>=) ma m = join $ fmap m ma
     (>>) ma mb = ma >>= \_ -> mb
    #+END_SRC
*** Laws
    join . return = id = join . fmap return

    join . join = join . fmap join
*** API
    #+BEGIN_SRC haskell
   filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
   mfilter :: (MonadPlus m) => (a -> Bool) -> m a -> m a
   foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> m a -> m b
   foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> m a -> m ()
   replicateM :: Monad m => Int -> m a -> m [a]
   replicateM_ :: Monad m => Int -> m a -> m ()
   (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
   (>>=) :: Monad m => m a -> (a -> m b) -> m b
   (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
   (=<<) :: Monad m => (a -> m b) -> m a -> m b
    #+END_SRC

** MonadPlus
   #+BEGIN_SRC haskell
   class Monad m => MonadPlus m where
     mzero :: m a
     mplus :: m a -> m a -> m a
   #+END_SRC
   it similar with Alternative, can used to implmenet Monoid

   match laws:
   - mzero `mplus` m = m
   - m `mplus` mzero = m
   - m `mplus` (n `mplus` o) = (m `mplus` n) `mplus` o
   - mzero >>= f = mzero
   - v >>= (\x -> mzero) = mzero
   - v >> mzero = mzero
   - mplus a b >>= k = mplus (a >>= k) (b >>= k)
* Functor Applicative Monad some function is similar, should use more general ** fmap liftA liftM #+BEGIN_SRC haskell fmap :: Functor f => (a -> b) -> f a -> f b liftA :: Applicative f => (a -> b) -> f a -> f b liftM :: Monad m => (a -> r) -> m a -> m r #+END_SRC ** forM mapM traverse #+BEGIN_SRC haskell forM :: (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b) mapM :: (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b) mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m () traverse :: (Applicative f, Traversable t) => (a -> f b) -> f b -> f (t b) #+END_SRC ** sequence sequenceA #+BEGIN_SRC haskell sequence :: (Monad m, Traversable t) => t (m a) -> m (t a) sequenceA :: (Applicative f, Traversable t) => t (f a) -> f (t a) #+END_SRC ** ap (<*>) #+BEGIN_SRC haskell ap :: Monad m => m (a -> b) -> m a -> m b (<*>) :: Applicative f => f (a -> b) -> f a -> f b #+END_SRC ** liftM2 liftM3 liftA2 liftA3 #+BEGIN_SRC haskell liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> mr liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d #+END_SRC
* IO
  IORef, used to save/get/modify memory value in IO monad
* API
** Prelude
   flip :: (a -> b -> c) -> b -> a -> c
   ($) :: (a -> b) -> a -> b, right associate, lowest precedence
   (.) :: (b -> c) -> (a -> b) -> a -> c, compose function, right associate
   lines :: String -> [String], split content by new line
   unline :: [String] -> String
   words :: String -> [String], split content by white space
   unwords :: [String] -> String
   seq :: a -> b -> b, force evaluate first argument then return second argument
   
** Data.List
   (++) :: [a] -> [a] -> [a], concat list
   head :: [a] -> a, get first element of list
   tail :: [a] -> [a], get element except first
   last:: [a] -> a, get last element of list
   init:: [a] -> [a], get element except last
   !! :: [a] -> Int -> a, get element by index(based 0)
   reverse :: [a] -> [a], reverse list
   take :: Int -> [a] -> [a], take n element from list
   drop :: Int -> [a] -> [a], drop n element then get list
   cycle :: [a] -> [a], generate infinity repeat list(from list, repeat pattern is list)
   repeat :: a -> [a], generate infinity repeat list(from element, repeat pattern is element)
   replicate :: Int -> a -> [a], repeat elemnt n times
   zip :: [a] -> [b] -> [(a,b)], length base on short one
   zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
   zip3 :: [a] -> [b] -> [c] -> [(a,b,c)]
   num :: Eq a => [a] -> [a], remove duplicate element
   splitAt :: Int -> [a] -> ([a], [a])
   span :: (a -> Bool) -> [a] -> ([a], [a]), takeWhile p + dropWhile p
   break :: (a -> Bool) -> [a] -> ([a], [a]), takeWhile (not p) + dropWhile (not p)
   partition :: (a -> Bool) -> [a] -> ([a], [a]), filter p + filter (not p)
   isPrefixOf :: Eq a => [a] -> [a] -> Bool
   isInfixOf :: Eq a => [a] -> [a] -> Bool
   isSuffixOf :: Eq a => [a] -> [a] -> Bool
   findIndex :: (a -> Bool) -> [a] -> Maybe Int
   findIndices :: (a -> Bool) -> [a] -> [Int]
   group :: Eq a => [a] -> [ [ a ] ]
   inits :: [a] -> [ [ a ] ]
   tails :: [a] -> [ [ a ] ]
   elemIndex :: Eq a => a -> [a] -> Maybe Int
   elemIndices :: Eq a => a -> [a] -> [Int]
   nub :: Eq a => [a] -> [a], remove duplicate
   union :: Eq a => [a] -> [a] -> [a], union with remove duplicate(only remove element from second list duplicate) e.g union [1,2] [1,1,3] = [1,2,3] union [1,1,2] [1,1,3] = [1,1,2,3]
   intersect :: Eq a => [a] -> [a] -> [a], keep same element(if element duplicate, not remove) e.g intersect [1,1,2] [1,1,3] = [1,1]
   insert :: Ord a => a -> [a] -> [a], insert element to first less or equal than it location
   delete :: Eq a => a -> [a] -> [a], delete first appear element
   (\\) :: Eq a -> [a] -> [a] -> [a], delete every element in second list from first list(duplicate in first list only remove n times occur in second list), e.g. [1,1,2,3] \\ [1,2] = [1,3]
   iterate :: (a -> a) -> a -> [a], generate infinity list by use f to generate value, init value is pass by arg, then value from previous result
   intersperse :: a -> [a] -> [a]
   interclate :: [a] -> [ [ a ] ] -> [a]
   transpose :: [ [a] ] -> [ [a] ], matrix transpose

** Data.Foldable
   length :: Foldable a => t a -> Int, get length of t a
   minimum :: (Foldable t, Ord a) => t a -> a, get mimimum element
   maximum:: (Foldable t, Ord a) => t a -> a, get mimimum element
   elem :: (Foldable t, Eq a) => a -> t a -> Bool, test is element exist
   notElem :: (Foldable t, Eq a) => a -> t a -> Bool
   sum :: (Folable t, Num a) => t a -> a
   product :: (Foldable t, Num a) => t a -> a
   concat :: Foldable t => t [a] -> [a]
   find :: (Foldable t) => (a -> Bool) -> t a -> Maybe a
   foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b, foldl' is strict version
   foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
   foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b, foldr' is strict version
   foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
   scanl:: Foldable t => (b -> a -> b) -> b -> t a -> [b]
   scanl1:: Foldable t => (a -> a -> a) -> t a -> [a]
   scanr:: Foldable t => (a -> b -> b) -> b -> t a -> [b]
   scanr1:: Foldable t => (a -> a -> a) -> t a -> [a]
   concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
   and :: Foldable t => t Bool -> Bool
   or :: Foldable t => t Bool -> Bool
   any :: Folable t => (a -> Bool) -> t a -> Bool
   all :: Folable t => (a -> Bool) -> t a -> Bool
   
** Data.Maybe
   data Maybe a = Nothing | Just a
** Data.Either
   data Either a b = Left a | Right b 
** Data.Function
   on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
** Data.Char
   generalCategory :: Char -> GHC.Unicode.GeneralCategory
   ord :: Char -> Int
   chr :: Int -> Char
   digitToInt :: Char -> Int, parse decimal char to int
   intToDigit :: Int -> Char
   toUpper :: Char -> Char
   toLower :: Char -> Char
   toTitle :: Char -> Char
** Data.Time

*** Data.Time.Calendar

    ModifiedJulianDay :: Integer -> Day, Julian Day set 1858/11/17 is first day

    toGregorian :: Day -> (Integer, Int, Int)

    isLeapYear :: Integer -> Bool

*** Data.Time.Clock Data.Time.Format

    getCurrentTime :: IO UTCTime

    formatTime :: FormatTime t => TimeLocale -> String -> t -> String

** Data.Tuple
   fst :: (a, b) -> a
   snd :: (a, b) -> b
** Data.Ratio
   (%) :: Integral a => a -> a -> Ratio a, constructor a ratio number

** Text.Printf

   printf :: PrintfType r => String -> r
** System.Environment

   getEnv :: String -> IO String, get environment value

   getArgs :: IO [String], get program called arguments

   getProgName :: IO String, get program self name

** System.IO / System.IO.Poxis / System.IO.Windows

   data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode

   - ReadMode, only read, throw exception if not exist
   - WriteMode, only write, clear content if file exist, create new if not exist
   - AppendMode, only write, append to end if file exist , create new if not exist
   - ReadWriteMode, read/write

   hFileSize :: Handle -> IO Integer, get file size

   hClose :: Handle -> IO ()

   readFile :: FilePath -> IO String, ReadMode

   writeFile :: FilePath -> String -> IO (), WriteMode

   appendFile :: FilePath -> String -> IO (), AppendMode

   openFile :: FilePath -> IOMode -> IO Handle, ReadWriteMode

   hSeek :: Handle -> SeekMode -> Integer -> IO (), move handle location

   hTell :: Handle -> IO Integer, get handle current location

   hIsEOF :: Handle -> IO Bool

   hGetChar :: Handle -> IO Char, get a character, move cursor to next location

   hGetLine :: Handle -> IO String, get a line, move cursor to next line

   getLine :: IO String, get line from stdin

   getContent :: IO String, get input content from stdin until EOF

   hLookAhead :: Handle -> IO Char, get next character, keep cursor don't move

   hGetContents :: Handle -> IO String, get rest of data and close handle, do not close handle before read all content(laziness)

   data BufferMode = NoBuffer | LineBUffering | BlockBuffering (Maybe Int)

   hSetBuffering :: Handle -> BufferMode -> IO (), change handle buffer mode

   hClose :: Handle -> IO ()

   hFlush :: Handle -> IO (), flush buffering data, auto called when hClose

   hPutChar :: Handle -> Char -> IO ()

   hPutStr :: Handle -> String -> IO ()

   hPutStrLn :: Handle -> String -> IO ()

   hPrint :: Show a => Handle -> a -> IO ()

   print :: Show a => a -> IO (), print = putStrLn . show

   BufferMode:
   - NoBuffering, cache single char
   - LineBuffering, cache line
   - BlockBuffering, cache a block, block size is define by Maybe arg
   
   hGetBuffering :: Handle -> IO BufferMode
   
   hSetBuffering :: Handle -> BufferMode -> IO ()

** System.Directory
   #+BEGIN_SRC haskell
   createDirectory :: FilePath -> IO ()
   removeDirectory :: FilePath -> IO () -- remove empty directory
   removeDirectoryRecursive :: FilePath -> IO ()
   renameDirectory :: FilePath -> FilePath -> IO ()
   setCurrentDirectory :: FilePath -> IO ()
   getDirectoryContents :: FilePath -> IO [FilePath]
   getTemporaryDirectory :: IO FilePath
   removeFile :: FilePath -> IO ()
   renameFile :: FilePath -> FilePath -> IO ()
   copyFile :: FilePath -> FilePath -> IO ()
   findFile :: [FilePath] -> String -> IO (Maybe FilePath)
   #+END_SRC

** System.Process

   callCommand :: String -> IO ()

   readProcess :: FilePath -> [String] -> String -> IO String

   shell :: String -> CreateProcess

   proc :: FilePath -> [String] -> CreateProcess

   createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

   waitForProcess :: ProcessHandle -> IO ExitCode, wait a process terminate and exit

   getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)

   terminateProcess :: ProcessHandle -> IO ()

** System.IO
   putStrLn :: String -> IO ()
** System.IO.Unsafe

   unsafePerfomrIO :: IO a -> a

   unsafeDupablePerformIO :: IO a -> a

   unsafeInterleaveIO :: IO a -> IO a, try delay IO execution as much as possible

   unsafeFixIO :: (a -> IO a) -> IO a

** System.Time

   data ClockTime = TOD Integer Integer, first argument is 1970/1/1 00:00:00, second is left picosecond

   getClockTime :: IO ClockTime

** System.Random

   better to use mwc-random package, it run faster

   mkStdGen :: Int -> StdGen

   newStdGen :: IO StdGen

   random :: (RandomGen g, Random a) => g -> (a, g)

   randomR :: RandomGen g => (a,a) -> g -> (a, g)

   randomRs :: RandomGen g => (a,a) -> g -> [a]

   getStdRandom :: (StdGen -> (a, StdGen)) -> IO a

* Monad instance

** Writer
   #+BEGIN_SRC haskell
   newtype Writer w a = Writer { runWriter :: (a, w) }

   instance (Monoid w) => Monad (Writer w) where
     return x = Writer (x, mempty)
     (Writer (x, v)) >>= f =
       let (Writer (y, v')) = f x
       in Writer (y, v `mappend` v')

   class (Monoid w, Monad m) => MonadWriter w m | m -> w where
     tell :: w -> m ()
     listen :: m a -> m (a, w)
     pass :: m (a, w -> w) -> m a

  listens :: (MonadWriter w m) => (w -> w) -> m a -> m (a, w)
  listens f m = do
    (a,w) <- listen m
    return (a, f w)

  censor :: (MonadWriter w m) => (w -> w) -> m a -> m a
  censor f m = pass $ do
    a <- m
    return (a, f)
   #+END_SRC

** Reader
   #+BEGIN_SRC haskell
   newtype Reader r a = Reader { runReader :: r -> a }

   instance Monad (Reader r) where
     return a = Reader $ \_ -> a
     m >>= k Reader $ \r -> runReader (k (runReader m r)) r

   class (Monad m) => MonadReader r m | m -> r where
     ask :: m r
     local :: (r -> r) -> m a -> m a

   instance MonadReader r (Reader r) where
     ask = Reader id
     local f m = Reader $ runReader m . f

   withReader :: (r' -> r) -> Reader r a -> Reader r' a
   withReader f m = Reader $ runReader m . f

   mapReader :: (a -> b) -> Reader r a -> Reader r b
   mapReader f m = Reader $ f . runReader m
   #+END_SRC

** State
   #+BEGIN_SRC haskell
     newtype State s a = State { runState :: s -> (a,s) }

     instance Monad (State s) where
       return x = State $ \s -> (x, s)
       State h >>= f = State $ \s ->
         let (a, newState) = h s
             (State g) = f a
         in g newState

     class (Monad m) => MonadState s m | m -> s where
       get :: m s
       put :: s -> m ()

     instance MonadState s (State s) where
       get = State $ \s -> (s, s)
       put s = State $ \_ -> ((), s)
   #+END_SRC
** Stream

   Control.Monad.Stream, can used for get value from multiple stream

** Free

   Free monad is wrap a functor become a monad, monad core is join :: m m a -> m a different than functor

   need define a seperate monadic explain to let a free monad go 'execute'

   #+BEGIN_SRC haskell
   data Free f a = Pure a | Free (f (Free f a))

   instance Functor f => Monad (Free f) where
     return = Pure
     Pure x >>= f = f x
     Free c >>= f = Free (fmap (>>= f) c)
   #+END_SRC

** Continuation

   #+BEGIN_SRC haskell
    newtype Cont r a = Cont { runCont :: (a -> r) -> r }

    instance Applicative (Cont r) where
      pure a = Cont \k -> k a
      -- cab :: Cont r (a->b) = ((a->b)->r)->r
      -- ca :: Cont r a = (a->r)->r
      -- cab <*> ca :: Cont r b = (b->r)->r
      cab <*> ca = Cont $ \br -> runCont cab (\ab -> runCont ca (\a -> br (ab a)))

    instance Monad (Cont r) where
      return = pure
      -- ca :: Cont r a = (a->r)->r
      -- acb :: a -> Cont r b = a -> (b->r)->r
      -- ca >>= acb :: Cont r b = (b->r)->r
      ca >>= acb = Cont $ \br -> runCont ca (\a -> runCont (acb a) (\b -> br b))
   #+END_SRC
* Monad Transfer

  IdentityT m ≃ mT Identity ≃ m

  m1Tm2T..mn, m1T will affect innerst, mn will in outst

** MonadT class

*** IdentityT

    no any affect, isomorphism with inner monad

    #+BEGIN_SRC haskell

   newtype Identity a = Identity { runIdentity :: a }

   newtype IdentityT m a = IdentityT { runIdentityT :: m a}

   

   instance (Monad m) => Monad (IdentityT m) where

     return = IdentityT . return

     m >>= k = IdentityT $ do

      a <- runIdentityT m

      runIdentityT (k a)

    #+END_SRC

*** MaybeT

    #+BEGIN_SRC haskell

   data Maybe a = Just a | Nothing

   data MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }

   

   instance Monad m => Monad (MaybeT m) where

     return = return . Just

     MaybeT a >>= f = 

       MaybeT $ do

         result <- a

         case result of 

           Nothing -> return Nothing

           Just x -> runMaybeT (f x)

    #+END_SRC

*** StateT

    #+BEGIN_SRC haskell

     newtype State s a = State { runState :: s -> (a,s) }

     newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }



     instance (Monad m) => (StateT s m) where

       return a = StateT $ \s -> return (a, s)

       m >>= k = StateT $ \s -> do

         (a, s') <- (runStateT m) s

         runStateT (k a) s'

    #+END_SRC

*** WriterT

    #+BEGIN_SRC haskell

     newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }

     instance (Monoid w, Monad m) => Monad (WriterT w m) where

       return a = WriterT $ return (a, mempty)

       m >>= k = WriterT $ do

         (a,w) <- runWriterT m

         (b, w') <- runWriterT (k a)

         return (b, w `mappend` w')

    #+END_SRC

** MonadTrans

   #+BEGIN_SRC haskell

   class MonadTrans t where

     lift :: Monad m => m a -> t m a



   class (Monad m) => MonadIO m where

     liftIO :: IO a -> m a

     

   class (Monad b, Monad m) => MonadBase b m | m -> b where

     liftBase :: b a -> m a

   #+END_SRC

   liftIO is because IO no correspond Monad Transfer, any monad can use liftIO once to get top define

   lift only determine once level, so if a high monad stack, need lift multiple times, liftBase provider a recursive definition, lift once get top definition

*** Laws

    lift . return = return

    lift (m >>= f) = lift m >>= lift f

* GHCi
  - :?, show help
  - :t, get type info, for infix opeartion, need enclose by ()
  - :i, get info, include type, for function include priority and associate
  - :set args <first> <second> <third> ..., can set arg to main function
  - :main [<first>,<second>,<third>...], call main with argument
  - :set +t, add type info on every result, :unset +t toogle off this setting
  - :m +<module>, import module
  - :m -<module>, remove moudle
  - :m, remove all import module
* Cabal
  cabal file name need same as package name
  #+BEGIN_SRC cabal
name:           ninety-nine-problem-haskell
version:        0.1.0.0
description:    Please see the README on GitHub at <https://github.com/724399396/ninety-nine-problem-haskell#readme>
homepage:       https://github.com/724399396/ninety-nine-problem-haskell#readme
bug-reports:    https://github.com/724399396/ninety-nine-problem-haskell/issues
author:         weili
maintainer:     liwei72439936@gmail.com
copyright:      2018 weili
license:        BSD3
license-file:   LICENSE
build-type:     Simple
cabal-version:  >= 1.10
extra-source-files:
    ChangeLog.md
    README.md

source-repository head
  type: git
  location: https://github.com/724399396/ninety-nine-problem-haskell

library
  exposed-modules:
      Lib
  other-modules:
      Paths_ninety_nine_problem_haskell
  hs-source-dirs:
      src
  build-depends:
      QuickCheck
    , base >=4.7 && <5
    , hspec
  default-language: Haskell2010

test-suite ninety-nine-problem-haskell-test
  type: exitcode-stdio-1.0
  main-is: Spec.hs
  other-modules:
      Paths_ninety_nine_problem_haskell
  hs-source-dirs:
      test
  ghc-options: -threaded -rtsopts -with-rtsopts=-N
  build-depends:
      QuickCheck
    , base >=4.7 && <5
    , hspec
    , ninety-nine-problem-haskell
  default-language: Haskell2010

  #+END_SRC
